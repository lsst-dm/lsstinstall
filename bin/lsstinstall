#!/bin/bash
# 
#  Rubin Observatory Deployment of EUPS top level product
#  
#    given an eups tag and a eups product to deploy the script will:
#    - check that LSST_HOME is set. This includes:
#          - creating $HOME/lsst_wrk (or the folder defined in a preexising $LSST_HOME)
#    - get the environment information required from the eups tags lists in:
#          https://eups.lsst.codes/stack/src/tags/
#    - check that the environment is available
#      - if it is available:
#        - activate the envionronment
#      - if it is not available:
#        - deploy the environment
#        - create a specific loadLSST_ENV.bash to activate the environment for future new shell
#    - activating the environment sourcing the corresponding load_LSST_ENV.bash
#    - execute:
#        eups distrib install -t <EUPS_TAG> <EUPS_PRODUCT>
#
#    To consider as prereq:
#    - conda (anaconda or miniconda)
#    - git
#
#    An additional script should be added in order to be able to switch between environments
#    - this is similar (but not the same) as envconfig
#
#############################################################################################


# defining the workspace, where lsstinstall will work
LSST_HOME="${LSST_HOME:-$HOME/lsst_wrk}"
# you can define a local EUPS_REPO_URL, use an absolute path
EUPS_REPO_URL="${EUPS_REPO_URL:-https://eups.lsst.codes}"
ENVS_FOLDER="${LSST_HOME}/envs"
# following string is used to build the EUPS_PKGROOT where binaries are stored
#    since the binaries should only depend on the conda environment,
#    there should be no need to include this in the EUPS_PKGROOT
USE_ONLY_SRC=false
CONDA_ENV_BASE_NAME=lsst-scipipe
SETUP_ONLY=false


#
# removing leading/trailing whitespace from a string
#
#http://stackoverflow.com/questions/369758/how-to-trim-whitespace-from-a-bash-variable#12973694
#
trimws() {
        local var="$*"
        # remove leading whitespace characters
        var="${var#"${var%%[![:space:]]*}"}"
        # remove trailing whitespace characters
        var="${var%"${var##*[![:space:]]}"}"
        echo -n "$var"
}


print_error() {
  >&2 echo -e "$@"
}


fail() {
  local code=${2:-1}
  [[ -n $1 ]] && print_error "$1"
  # shellcheck disable=SC2086
  exit $code
}


usage() {
  if [[ ! -z "$1" ]]; then
    print_error "$0: $1"
  fi

  # note that heredocs are prefixed with tab chars
  fail "$(cat <<-EOF
		Usage: $0 [-h] [-s] -t eups_tag eups_product

		-t          Install eups_tag of eups_product after ensuring that the proper conda environment is available. 
		            In case it is not, it will be deployed and activated before execute the eups distrib install..

		-s          Only use EUPS source "eupspkg" packages.
		            Do not use together with -p option.

		-p          Prepare Only. Check if the environment for a specific build is available.
		            In case it is not, it will be deployed and the activation script generated.
		            No eups distrib install will be executed.
		            Config file (to source) is regenerate.
		            Do not use together with -s option

		-h          Show this message
		
	EOF

  )"
}


check_conda() {
  # activating conda
  CONDA_PATH=$(which conda)
  CONDA_DIR=$(dirname "${CONDA_PATH}")
  # shellcheck disable=SC1090  
  . "${CONDA_DIR}/../etc/profile.d/conda.sh"
}


config_curl() {
  # Prefer system curl; user-installed ones sometimes behave oddly
  if [[ -x /usr/bin/curl ]]; then
    CURL=${CURL:-/usr/bin/curl}
  else
    CURL=${CURL:-curl}
  fi

  # disable curl progress meter unless running under a tty -- this is intended to
  # reduce the amount of console output when running under CI
  CURL_OPTS=('-#')
  if [[ ! -t 1 ]]; then
    CURL_OPTS=('-sS')
  fi

  # curl will exit 0 on 404 without the fail flag
  CURL_OPTS+=('--fail')
}


parse_args() {
  local OPTIND
  local opt

  while getopts "stph" opt; do
    case "$opt" in
    s)
      USE_ONLY_SRC=true
      ;;
    p)
      SETUP_ONLY=true
      ;;
    t)
      # if -s option is giving, an extra shift is required
      if [ $# = 4 ]; then shift; fi
      shift;
      EUPS_TAG=$1
      EUPS_PRODUCT=$2
      ;;
    h)
      usage
      ;;
    *)
      usage "Unknown option: ${opt}"
      ;;
    esac
  done
  shift $((OPTIND-1))

  echo "use only sources: $USE_ONLY_SRC"
  echo "setup-only:       $SETUP_ONLY"
}


create_load_script() {
  echo "File to source: $config_file"
  cmd_setup_conda="$(cat <<-EOF
	export LSST_CONDA_ENV_NAME=${LSST_CONDA_ENV_NAME}
	# shellcheck disable=SC1091
	source "${CONDA_DIR}/../etc/profile.d/conda.sh"
	if conda env list | grep "^eups "  > /dev/null; then
	  conda activate eups
	else
	  echo "Environment EUPS base environment missing"
	  return
	fi
	conda activate --stack "\$LSST_CONDA_ENV_NAME"
	
	EOF
  )"

  # shellcheck disable=SC2094
  cat > "${config_file}" <<-EOF
		# This script is intended to be used with bash to load the LSST environment for:
		#     eups product: ${EUPS_PRODUCT}
		#     eups tag:     ${EUPS_TAG}
		#
		# Usage: source $(basename "$config_file")

		${cmd_setup_conda}
		LSST_HOME="${LSST_HOME}"
		EUPS_BIN_PKGROOT="${EUPS_BIN_PKGROOT}"
		EUPS_SRC_PKGROOT="${EUPS_SRC_PKGROOT}"

		# Bootstrap EUPS
		# EUPS_DIR is defined in the conda environment itself
		source "\${EUPS_DIR}/bin/setups.sh"
		export -f setup
		export -f unsetup

		if [ "\${1}" = "-s" ]; then
		  export EUPS_PKGROOT=\${EUPS_PKGROOT:-\${EUPS_SRC_PKGROOT}}
		else
		  export EUPS_PKGROOT=\${EUPS_PKGROOT:-\${EUPS_BIN_PKGROOT}|\${EUPS_SRC_PKGROOT}}
		fi
		export EUPS_PATH=${EUPS_PATH}
		echo "Eups ready:"
		echo "  EUPS_PATH: \${EUPS_PATH}"
		echo "  EUPS_PKGROOT: \${EUPS_PKGROOT}"
	EOF

}


define_platform() {

  case $(uname -s) in
    Linux*)
      pkg_postfix='linux-64'
      local release_file='/etc/redhat-release'
      if [[ ! -e $release_file ]]; then
         print_error "unknown osfamily"
         #[[ $__debug == true ]] && print_error "unknown osfamily"
      fi
      osfamily="redhat"

      # capture only major version number because "posix character classes"
      if [[ ! $(<"$release_file") =~ release[[:space:]]*([[:digit:]]+) ]]; then
         print_error "unable to find release string"
         #[[ $__debug == true ]] && print_error "unable to find release string"
      fi
      osrelease="${BASH_REMATCH[1]}"
      case $osrelease in
        6)
          osplatform=el6
          target_cc=devtoolset-8
          ;;
        7)
          osplatform=el7
          target_cc=devtoolset-8
          ;;
        *)
          print_error "unsupported release: $osrelease"
          #[[ $__debug == true ]] && print_error "unsupported release: $__release"
          ;;
        esac
      ;;
    Darwin*)
      osfamily="osx"
      pkg_postfix='osx-64'
      target_cc=clang-1000.10.44.4

      if ! release=$(sw_vers -productVersion); then
         print_error "unable to find release string"
         #[[ $__debug == true ]] && print_error "unable to find release string"
      fi
      osrelease=$(trimws "$release")
      case $osrelease in
        # XXX bash 3.2 on osx does not support case fall-through
        10.9.* | 10.1?.* | 10.1?)
          osplatform=10.9
          target_cc=clang-1000.10.44.4
          ;;
        *)
          print_error "unsupported release: $osrelease"
          #[[ $__debug == true ]] && print_error "unsupported release: $osrelease"
          ;;
        esac
      ;;
    *)
      print_error "unknown osfamily"
      #[[ $__debug == true ]] && print_error "unknown osfamily"
      ;;
  esac
  echo "  ... configuring enfironment for:"
  echo "      os-family: ${osfamily}"
  echo "      os-release: ${osrelease}"
  echo "      os-platform: ${osplatform}"
  echo "      pkg_postfix: ${pkg_postfix}"
  echo "      compiler: ${target_cc}"

}


discover_url(){
  # search $2 in the second level deep of $1
  # It would be preferable to have this information stored in eups.lsst.codes for each build
  #  - compiler
  #  - miniconda version
  first_level=$(curl -s "${1}" | sed -e 's/<[^>]*>//g' | grep nbsp | grep -v Parent | awk -F '/' '{ print $1 }')
  local BIN_PATH=''
  for line in ${first_level}
  do
    url="${1}/${line}"
    #(curl -s "${url}" | sed -e 's/<[^>]*>//g' | grep nbsp | grep -v Parent)
    second_level=$(curl -s "${url}" | sed -e 's/<[^>]*>//g' | grep nbsp | grep -v Parent | awk -F '/' '{ print $1 }' | grep "$2")
    for path in ${second_level}
    do
      if [[ ${BIN_PATH} == '' ]]; then
        BIN_PATH="${url}/${path}" 
      else
        BIN_PATH="${BIN_PATH}|${url}/${path}"
      fi
    done
  done
  echo "${BIN_PATH}"
}


create_environment() {

  local env_def_file="conda-${pkg_postfix}.lock"
  local env_url="https://raw.githubusercontent.com/${ENV_REPO_ORG}/${ENV_REPO_NAME}/${ENV_REF}/etc/"
  local env_file="${ENVS_FOLDER}/${ENV_REF}/${env_def_file}.yml"
  echo " ... looking for ${env_def_file} in ${env_url}"
  mkdir -p "${env_file%/*}"
  # downloading environment definitino file
  $CURL "${CURL_OPTS[@]}" -# -L "${env_url}/${env_def_file}" --output "${env_file}"  
  # creating environment
  conda create --name "${LSST_CONDA_ENV_NAME}" --file "${env_file}"

  # DISABLED: using stacked environment instead
  ## setting up eups
  # conda activate "${LSST_CONDA_ENV_NAME}"  
  #conda info | grep "active environment"
  ## checking if eups is included in the environment
  #if ! which eups > /dev/null; then
  #  conda install -y eups -c conda-forge
  #fi
  #
  #conda deactivate

  # creating new EUPS_PATH
  EUPS_PATH="${LSST_HOME}/stacks/${ENV_REF}"
  mkdir -p "${EUPS_PATH}"/{site,ups_db}


  # set EUPS_PKG_ROOT
  EUPS_BIN_PKGROOT=$(discover_url "${EUPS_REPO_URL}/stack/${osfamily}/${osplatform}" "${ENV_REF}")
  echo "Found EUPS binary path:   $EUPS_BIN_PKGROOT"
  EUPS_SRC_PKGROOT="${EUPS_REPO_URL}/stack/src"
  echo "$EUPS_SRC_PKGROOT"
  if [[ "${EUPS_BIN_PKGROOT}" != "" ]]; then
    EUPS_PKGROOT="${EUPS_BIN_PKGROOT}|${EUPS_SRC_PKGROOT}"
  else
    EUPS_PKGROOT="${EUPS_SRC_PKGROOT}"
  fi
  echo "$EUPS_PKGROOT"

  create_load_script

}

fix_config_file() {
  # the environment exists but not the config file to activate it
  # this functino is to recreate the config file

  # creating new EUPS_PATH
  EUPS_PATH="${LSST_HOME}/stacks/${ENV_REF}"
  mkdir -p "${EUPS_PATH}"/{site,ups_db}

  # set EUPS_PKG_ROOT
  EUPS_BIN_PKGROOT=$(discover_url "${EUPS_REPO_URL}/stack/${osfamily}/${osplatform}" "${ENV_REF}")
  echo "Found EUPS binary path:   $EUPS_BIN_PKGROOT"
  EUPS_SRC_PKGROOT="${EUPS_REPO_URL}/stack/src"
  echo "$EUPS_SRC_PKGROOT"
  if [[ "${EUPS_BIN_PKGROOT}" != "" ]]; then
    EUPS_PKGROOT="${EUPS_BIN_PKGROOT}|${EUPS_SRC_PKGROOT}"
  else
    EUPS_PKGROOT="${EUPS_SRC_PKGROOT}"
  fi
  echo "$EUPS_PKGROOT"

  config_folder="${ENVS_FOLDER}/${ENV_REF}"
  echo "$config_folder"

  if [ ! -d "$config_folder" ]; then
    mkdir -p "$config_folder"
  fi

  create_load_script

}

set_environment() {
  LIST_BASE_URL="${EUPS_REPO_URL}/stack/src/tags"
  LIST_URL="${LIST_BASE_URL}"/"${EUPS_TAG}".list
  # check if it is not an https link
  if [[ "${LIST_URL:0:4}" != "http" ]]; then
    # in this case the provided repo URL has to be an absolute path
    if [[ "${LIST_URL:0:1}" == "/" ]]; then
      LIST_URL="file://${LIST_URL}"
    else
      fail "Error defining EUPS_PKGROOT: provided wrong input in EUPS_REPO_URL:\n -> ${EUPS_REPO_URL}"
    fi
  fi
  echo "Looking for environment information in:\n --> $LIST_URL"
  RAW_ENV_INFO=$("${CURL}" -s "${LIST_URL}" | grep CONDA_ENV)

  if [ -z "${RAW_ENV_INFO}" ]; then
    fail "Eups tag ${EUPS_TAG} for product ${EUPS_PRODUCT} not related to any environment."
  fi

  RAW_ENV_REPO=$(echo "${RAW_ENV_INFO}" | awk -F '=' '{ print $2 }')
  ENV_REPO_URL=$(echo "${RAW_ENV_REPO}" | awk -F '@' '{ print $1 }')
  ENV_REF=$(echo "${RAW_ENV_REPO}" | awk -F '@' '{ print $2 }')
  ENV_REPO_NAME=$(echo "${ENV_REPO_URL}" | awk -F '/' '{ print $5 }' | awk -F '.' '{ print $1 }')
  ENV_REPO_ORG=$(echo "${ENV_REPO_URL}" | awk -F '/' '{ print $4 }')
  # echo "Retriving conda environment information forom respository ${ENV_REPO_URL}, SHA-1 ${ENV_REF}."

  export LSST_CONDA_ENV_NAME="${CONDA_ENV_BASE_NAME}-${ENV_REF}"

  # defining the filename to source for environment configuration
  config_file="${ENVS_FOLDER}/${ENV_REF}/loadLSST_${ENV_REF}_env.sh"

  # check if the environment exist
  ENV_CHECK=$(conda env list | grep "^${LSST_CONDA_ENV_NAME}")
  if [ -z "${ENV_CHECK}" ]; then
    echo " ... creating new environemnt ${LSST_CONDA_ENV_NAME} ..."
    create_environment "${LSST_CONDA_ENV_NAME}"
  fi

  # check if config file exists
  # config file regenerated when setup-only is given
  if [ ! -f "${config_file}" -o "$SETUP_ONLY" == "true" ] ; then
    echo " ... config file missing, recreating environemnt ${LSST_CONDA_ENV_NAME} ..."
    fix_config_file "${LSST_CONDA_ENV_NAME}"
  fi
  # source config file to enable environment
  if [ "${USE_ONLY_SRC}" == "false" ]; then
    echo "  ... configuring eups to install binary packages if available."
    # shellcheck disable=SC1090
    source "${config_file}"
  else
    echo "  ... configuring eups to only build from source packages."
    # shellcheck disable=SC1090
    source "${config_file}" -s
  fi

  echo "Environment ${LSST_CONDA_ENV_NAME} activated."

}


main() {
  config_curl

  parse_args "$@"

  # create the workspace folder if it doesn't exists
  echo "LSST_HOME set to ${LSST_HOME}"
  mkdir -p "${LSST_HOME}"

  # It assumes a valid conda is already installed
  # we can add a check and if not present install a miniconda
  # howeverm if this tool is distributed as conda package this is not needed
  check_conda

  #echo "Preparing ..."
  define_platform
  #echo $EUPS_BIN_PKGROOT

  #discover_url "${EUPS_REPO_URL}/stack/${osfamily}/${osplatform}" "46b24e8"
  #local EBP=$(discover_url "${EUPS_REPO_URL}/stack/${osfamily}/${osplatform}" "46b24e8")
  #echo "BinPath: ${EBP}"

  echo "Setting environment ..."
  set_environment
  echo
  #echo "  EUPS Product: ${EUPS_PRODUCT}"
  #echo "  EUPS Tag:     ${EUPS_TAG}"
  if [ "$SETUP_ONLY" == "false" ]; then
    echo "Installing distribution:"
    echo "  eups distrib install -t ${EUPS_TAG} ${EUPS_PRODUCT}"
    eups distrib install -t "${EUPS_TAG}" "${EUPS_PRODUCT}" 
    echo "DONE."
    echo
    echo "Before using the installed distribution, activate the conda enviroment as follows:"
    echo "    source ${config_file} [-s to use only source packages]"
  else
    echo "Setup Only."
    echo "Activate the environment as follows:"
    echo "    source ${config_file} [-s to use only source packages]"
    echo
    echo "and then install the distribution:"
    echo "    eups distrib install -t ${EUPS_TAG} ${EUPS_PRODUCT}"
  fi
  echo
  echo "or see how to activate the environment using envconfig:"
  echo "    envconfig -h"
  echo

}

main "$@"
